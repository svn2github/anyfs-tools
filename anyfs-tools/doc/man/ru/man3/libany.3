.TH libany 3 "15 Aug 2006" "Version 0.84.5"
.SH "НАЗВАНИЕ"
libany \- библиотека anyfs-tools.

.SH "СИНТАКСИС"
.B #include <any.h>
.sp
.B #include <super.h>
.sp
.B #include <bitops.h>
.sp
.B #include <block_map.h>
.sp
.B #include <new_inode.h>
.sp
.B #include <release_fssys.h>
.sp
.B #include <progress.h>
.sp
.B #include <version.h>

.SH "ОПИСАНИЕ"
Библиотека 
.B libany 
используется утилитами
.BR anyfs-tools .

.SH "СТРУКТУРЫ ТАБЛИЦЫ ИНФ.УЗЛОВ"
Структуры для хранения таблицы инф.узлов в памяти объявлены в файле
.B any.h
.SS "ИНФОРМАЦИЯ СУПЕРБЛОКА"
.nf
struct any_sb_info {
	char *si_itfilename;               /* имя файла таблицы инф.узлов */
	unsigned long si_blocksize;        /* размер блока */
	unsigned long si_inodes;           /* число инф.узлов */
	unsigned long *si_inode_bitmap;    /* карта инф.узлов */
	struct any_inode *si_inode_table;  /* массив инф.узлов */
};
.fi
Эта структура -- аналог суперблока в других файловых системах.

Поле
.B si_itfilename
сохраняется при открытии таблицы инф.узлов и используется при сохранении, если \
не указано другого имени файла для записи таблицы инф.узлов.

Поле
.B si_inode_bitmap
это карта битов обозначающих занят ли тот или иной инф.узел
(т.е. 1 значит занят).

Поле
.BR si_inode_table " --"
собственно таблица инф.узлов. Массив из
.B si_inodes
структур
.B any_inode
(будут описаны ниже).

.SS "ИНФОРМАЦИОННЫЙ УЗЕЛ"
.nf
struct any_inode {
    uint16_t  i_mode;         /* Режим доступа */
    uint16_t  i_uid;          /* Идентификатор пользователя */
    uint16_t  i_gid;          /* Идентификатор группы */
    uint64_t  i_size;         /* Размер в байтах */
    uint32_t  i_atime;        /* Время доступа */
    uint32_t  i_ctime;        /* Время создания */
    uint32_t  i_mtime;        /* Время модификации */
    uint16_t  i_links_count;  /* Число ссылок */
    union {
        struct any_file_frags   *file_frags; /* Фрагменты файла */
        struct any_dir          *dir;        /* Элементы директории */
        char   *symlink;                     /* Символическая ссылка */
        dev_t  device;                       /* Устройство */
    } i_info;
    size_t    i_it_file_offset; /* Смещение в файле таблицы инф.узлов */
}
.fi

Это структура является несколько модифицированной аналогичной \
структурой файловой системы ext2fs
.BR ext2_inode .

Описание большинства элементов вы можете найти в
.IR stat(2) .

Объединение
.B i_info
содержит ссылку на часть информации об инф.узле зависимую от типа \
инф.узла.

Для простого файла -- это описание расположения его фрагментов на диске.

Для директорий -- список её элементов.

Для символических ссылок -- строка ссылки.

Для устройства -- тип устройства (см. описание элемента
.B st_rdev
в структуре
.IR stat(2) )

Поле
.B i_it_file_offset
используется функцией сохранения таблицы инф.узлов.

.SS "ДИРЕКТОРИЯ"
Директорию описывает следующая структура:
.nf
struct any_dir {
        uint32_t              d_ndirents; /* число элементов */
        struct any_dirent*    d_dirent;   /* первый элемент директории */
};
.fi

Поле
.B d_dirent
является указателем на односвязный список элементов директории.

.SS "ЭЛЕМЕНТ ДИРЕКТОРИИ"
.nf
struct any_dirent {
        char*               d_name;  /* имя элемента */
        uint32_t            d_inode; /* номер инф.узла */
        struct any_dirent   *d_next; /* следующий элемент директории */
};
.fi

.SS "ФРАГМЕНТЫ ФАЙЛА"
Для простого файла хранится информация о расположении его на диске \
в следующей структуре:
.nf
struct any_file_frags {
        uint32_t                   fr_nfrags; /* число фрагментов */
        struct any_file_fragment   *fr_frags; /* фрагменты */
};
.fi
Поле
.B fr_frags
является массивом из
.B fr_nfrags
элементов, описывающих каждый фрагмент файла.

.SS "ФРАГМЕНТ ФАЙЛА"
.nf
struct any_file_fragment {
        uint32_t    fr_start;     /* номер начального блока фрагмента */
        uint32_t    fr_length;    /* длина фрагмента в блоках */
};
.fi

Размер блока, используемый в этой структуре в качестве единицы измерения, \
определён в структуре
.BR any_sb_info .

Значение 0 элемента
.B fr_start
означает sparse-фрагмент (такой который не хранится на диске, но считается, \
что он заполнен нулями)

.SH "СОЗДАНИЕ/ЗАГРУЗКА/СОХРАНЕНИЕ ТАБЛИЦЫ ИНФ.УЗЛОВ"
Следующие функции объявлены в файле
.BR super.h .

.TP
.BI "int alloc_it(struct any_sb_info **" it ", unsigned long " blocksize \
		", unsigned long " inodes ");"
Выделяет память для таблицы инф.узлов с размером блока
.B blocksize
и максимальным числом инф.узлов
.BR inodes , 
помещая указатель на структуру
.B any_sb_info
в
.BR *it .

Новая таблица инф.узлов заполняется нулями.

Возвращает 0 в случае успеха или -ENOMEM в случае не хватки памяти.

.TP
.BI "int realloc_it(struct any_sb_info *" it ", unsigned long " inodes ");"
Использует
.B realloc
чтобы изменить максимальное число элементов в таблице инф.узлов
.B it 
на
.BR inodes .

Имейте ввиду, что после этого вызова элементы 
.B si_inode_bitmap
и
.B si_inode_table
структуры
.B any_sb_info
таблицы инф.узлов могут изменить своё значение \
(т.е. таблица и карта инф.узлов могут изменить своё расположение \
в памяти) и любые указатели на инф.узлы вычисленные перед \
этим вызовом выражением вроде
.I (it->si_inode_table + ino)
или
.IR &(it->si_inode_table[ino]) .
потребуют обновления.

Возвращает 0 в случае успеха или выходит из программы со статусом ENOMEM.

.TP
.BI "int read_it(struct any_sb_info **" it ", char " itfilename "[]);"
Загружает таблицу инф.узлов из файла
.B itfilename
в память, помещая указатель на неё в
.BR *it .

Возвращает 0 в случае успеха или -ENOMEM, -ENAMETOOLONG, -EINVAL в случае \
ошибки. В случае ошибки ввода/вывода переменная errno будет \
хранить более точный код ошибки.

.TP
.BI "int write_it(struct any_sb_info *" it ", char " itfilename "[]);"
Сохраняет таблицу инф.узлов
.B it
в файл
.BR itfilename .

Если 
.B itfilename 
.IR "== NULL" ,
то берёт имя файла из поля
.BR it->si_itfilename .

Имейте ввиду, что этот вызов не освобождает память занимаемую \
таблицей инф.узлов (хотя вызов
.B read_it
выделяет память под загружаемую таблицу инф.узлов)

Возвращает 0 в случае успеха или 1 в случае ошибки. \
В случае ошибки ввода/вывода переменная errno будет \
хранить более точный код ошибки.

.TP
.BI "void free_it(struct any_sb_info *" info ");"
Освобождает память, занимаемую таблицей инф.узлов.

.SH "РАБОТА С КАРТАМИ БИТОВ"
Следующие функции объявлены в файле
.B bitops.h

.TP
.BI "int test_and_set_bit(unsigned int " nr ", unsigned long* " addr ");"
Устанавливает бит
.B nr
в карте битов
.BR addr .

Возвращает значение бита перед установкой.

.TP
.BI "set_bit(unsigned int " nr ", unsigned long* " addr ");"
Устанавливает бит
.B nr
в карте битов
.BR addr .

.TP
.BI "int test_and_clear_bit(unsigned int " nr ", unsigned long* " addr ");"
Очищает бит
.B nr
в карте битов
.BR addr .

Возвращает значение бита перед очищением.

.TP
.BI "clear_bit(unsigned int " nr ", unsigned long* " addr ");"
Очищает бит
.B nr
в карте битов
.BR addr .

.TP
.BI "int test_bit(unsigned int " nr ", unsigned long* " addr ");"
Возвращает значение бита 
.B nr
в карте бит
.BR addr .

.TP
.BI "int find_first_zero_bit(const unsigned long* " addr ", int " size ");"
Ищет первый нулевой бит в карте битов
.B addr 
размером
.BR size.

Возвращает номер найденного бита, или значение не меньшее
.B size
в случае неудачи.

.TP
.BI "int find_next_zero_bit(const unsigned long* " addr ", int " size ", int " offset);"
Ищет первый, начиная с бита
.BR offset ,
нулевой бит в карте битов
.B addr 
размером
.BR size.

Возвращает номер найденного бита, или значение не меньшее
.B size
в случае неудачи.

.SH "СОЗДАНИЕ КАРТЫ БЛОКОВ"
Следующие функции объявлены в файле
.B block_map.h

.TP
.BI "int fill_block_bitmap(struct any_sb_info *" info ", unsigned long *" block_bitmap ", any_blk_t " dev_size);"
Заполняет карту блоков, помечая блоки занятые простыми файлами, \
в соответствии с информацией из таблицы инф.узлов
.B info
для устройства размером
.BR dev_size .

Карта перед вызовом этой функции должна быть выделена \
в памяти и заполнена нулями.

Кроме прочих блоков функция помечает нулевой блок как системный.

Функция возвращает 0 в случае успеха или -1, если в таблице инф.узлов \
найдены файлы, разделяющие между собой информацию одних и тех же блоков.

Это значит, что в процессе своей работы функция не должна ни разу \
найти уже установленного бита в карте блоков (вероятно, помеченного ей же \
как используемый блок другим инф.узлом).

.SH "СОЗДАНИЕ ФАЙЛОВ В ANYFS"
Следующие функции объявлены в файле
.B new_inode.h

.TP
.BI "int any_new_inode(struct any_sb_info *" info ", int " mode ", void* "\
                data ", uint32_t " dirino ", uint32_t *" newino ");"
Создаёт инф.узел в таблице инф.узлов
.B info
с режимом доступа (и типом)
.B mode 
в директории инф.узла
.BR dirino .

Номер нового инф.узла помещается в переменную
.BR *newino .

В случае создания устройства (специального файла), указатель
.B data
должен указывать на переменную типа
.B dev_t
содержащей тип устройства.

Возвращает ноль в случае успеха. Завершает работу программы при
не хватке памяти.

.TP
.BI "int getpathino(char *" path ", uint32_t " root ", struct any_sb_info*"\
                  info ", uint32_t *" ino ");"
Ищет элемент (директорию) с именем (путём)
.B path
считая корневым инф.узел (директорию)
.B root
в таблице инф.узлов
.BR info .

Помещает номер найденного инф.узла в переменную
.BR *ino .

Возвращает 0 в случае успеха, 1 -- в случае отсутствия жлемента с таким
именем, или -1, если инф.узел
.B root
не является директорией или является свободным инф.узлом.

.TP
.BI "int mkpathino(char *" path ", uint32_t " root ", struct any_sb_info*"\
                info ", uint32_t *" ino ");"
Тоже что
.BR getpathino() ,
но создаёт все директории пути в случае их отсутствия.

При этом в программе должна быть объявлена переменная
.IB mode_t " dir_umask;"
содержащая маску сбрасываемых бит доступа для создаваемых директорий.

.SH "ОСВОБОЖДЕНИЕ СИСТЕМНЫХ БЛОКОВ"
Следующие функции объявлены в файле
.B release_fssys.h

.TP
.BI "typedef int any_rwblk_t(unsigned long " from ", unsigned long " n \
              ", char *" buffer ");"
Тип функции чтения/записи блока.

Функция этого типа должна считывать/записывать блоки начиная с
.B from
в количестве
.B n
штук в/из (заранее выделенного) буфера
.BR buffer .

Функция должна возвращать 0 в случае успеха, или отрицательное значение \
в случае ошибки ввода/вывода.

.TP
.BI "extern any_rwblk_t *" any_readblk ";"
Указатель на функцию чтения блока с устройства.

Присвойте этому указателю правильное значение перед вызовом
.BR any_release() .

.TP
.BI "extern any_rwblk_t *" any_writeblk ";"
Указатель на функцию записи блока на устройство.

Присвойте этому указателю правильное значение перед вызовом
.BR any_release() .

.TP
.BI "typedef int any_testblk_t(unsigned long " bitno ");"
Тип функции проверки занятости блока номер
.B bitno
устройства.

Функция этого типа должна возвращать 0, если проверяемый блок свободен.

.TP
.BI "extern any_testblk_t *" any_testblk ";"
Указатель на функцию проверки занятости блока устройства.

Эта функция должна возвращать 1, только, если блок устройства будет \
занят системной информацией.

Присвойте этому указателю правильное значение перед вызовом
.BR any_release() .

.TP
.BI "typedef unsigned long any_getblkcount_t();"
Тип функции для получения размера устройства в блоках.

.TP 
.BI "extern any_getblkcount_t *" any_getblkcount ";"
Указатель на функцию получения размера устройства.

Присвойте этому указателю правильное значение перед вызовом
.BR any_release() .

.TP
.BI "int any_release(struct any_sb_info *" info ", unsigned long*" \
                 block_bitmap ", unsigned long " start \
                 ", unsigned long " length ");"
Освобождает
.B length
(в будущем) системных блоков ФС, начиная с блока
.BR start ,
от пользовательской информации, \
основываясь на информации из таблицы инф.узлов
.B info
карте блоков (пользовательской информации)
.BR block_bitmap .

Функция будет использовать функции
.B any_readblk
и
.B any_writeblk
для чтения/записи с устройства, функцию
.B any_getblkcount
для получения размера устройства, а также функцию
.B any_testblk
для получения информации о расположении системных блоков на устройстве.

.TP
.BI "int any_adddadd(struct any_sb_info *" info ");"
Функция добавляет во все директории таблицы инф.узлов
.B info
элементы "." и ".."

Эта функция используется в утилитах построения файловых систем
.BR build_e2fs " и " build_xfs ,
после освобождения блоков от системной информации. Именно поэтому
её объявление не было перенесено в другой файл.

.SH "СТРОКА ПРОГРЕССА"
Следующие функции объявлены в файле
.B progress.h

Эти функции были взяты из e2fsprogs и немного модифицированы.

.TP
.B struct progress_struct;
Структура для сохранения данных прогресса. Поля этой структуры \
используются функциями ниже, программисту использующему эти функции \
нет нужды исправлять их самостоятельно

.TP
.BI "void progress_init(struct progress_struct *" progress \
                 ", const char *" label ", uint32_t " max ");"
Инициализация строки прогресса
.B progress
с именем (пояснением действий программы для пользователя)
.B label
и максимальным значением
.BR max .

Максимальное значение установленное в ноль будет означать что \
число обрабатываемых единиц (блоков, файлов и т.п.) не известно \
(возможно эта строка прогресса будет отображать подсчёт этих элементов), \
в этом случае строка прогресса будет выглядеть не как
.br
<пояснение>: <номер обрабатываемого элемента>/<всего элементов>

а без указания максимального числа элементов:
.br
<пояснение>: <номер обрабатываемого элемента>

Эта возможность используется в
.B build_it 
для файловых систем которые не выдают правильное значение числа используемых \
инф.узлов (например, VFAT).

.TP
.BI "void progress_update(struct progress_struct *" progress \
                 ", uint32_t " val ");"
Обновление строки прогресса
.B progress
до значения
.BR val .

Эта функция записывает новое значение прогресса и возвращает курсор \
назад для записи следующего значения.

.TP
.BI "void progress_close(struct progress_struct *" progress ");"
Закрытие строки прогресса
.BR progress .

.TP
.BI "void progress_update_non_backup(struct progress_struct *" progress \
                 ", uint32_t " val ");"
Обновление строки прогресса
.B progress
до значения
.B val 
без возвращения курсора для записи следующего значения.

Эта функция используется в
.B anysurrect
для помещения в строку прогресса индикатора обозначающего тип распознаватель,
которого работает в данный момент.

.TP
.BI "void progress_backup(struct progress_struct *" progress ");"
Возвращает курсор для записи следующего значения прогресса.

Эта функция используется в
.B anysurrect
для помещения в строку прогресса индикатора обозначающего тип распознаватель,
которого работает в данный момент.

.SH "ВЕРСИЯ ANYFS-TOOLS"
Файл
.B version.h
имеет объявление двух макросов:

.TP
.B ANYFSTOOLS_VERSION
Строка обозначающая версию пакета anyfs-tools.

.TP
.B ANYFSTOOLS_DATE
Строка обозначающая дату релиза данной версии пакета anyfs-tools.

.SH "АВТОР"
Николай Кривченков aka unDEFER <undefer@gmail.com>

.SH "СООБЩЕНИЯ ОБ ОШИБКАХ"
Сообщения о любых проблемах с применением пакета
.B anyfs-tools
направляйте по адресу:
undefer@gmail.com

.SH "ДОСТУПНОСТЬ"
последнюю версию пакета вы можете получить на сайте проекта: \
http://anyfs-tools.sourceforge.net

.SH "СМ. ТАКЖЕ"
.BR anyfs-tools(8),
.BR build_it(8),
.BR anysurrect(8),
.BR stat(2)
